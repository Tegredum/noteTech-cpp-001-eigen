# Eigen 计算逆矩阵的原理公式

encoding: utf-8

author: Grok 4 Expert

Eigen 是一个高效的 C++ 线性代数库，它通过 `MatrixBase::inverse()` 方法计算矩阵的逆矩阵。该方法返回一个 `Inverse<Derived>` 对象，该对象在求值时会根据矩阵的大小和类型选择不同的计算策略。Eigen 的逆矩阵计算主要基于以下原理：

1. **对于小尺寸固定矩阵（1x1、2x2、3x3、4x4）**：使用直接的代数公式，通常基于行列式（determinant）和伴随矩阵（adjugate matrix）。这些是封闭形式的计算，避免了迭代或分解的开销。
2. **对于一般尺寸矩阵**：使用部分主元 LU 分解（Partial Pivoting LU Decomposition），然后通过求解线性方程组得到逆矩阵。这是一种数值稳定的方法，适用于任意可逆方阵。

Eigen 假设矩阵是可逆的（不会自动检查奇异性，用户需自行确保）。如果需要检查可逆性，可以使用 `computeInverseAndDetWithCheck()` 或全主元 LU 分解（FullPivLU）。

下面基于提供的代码（特别是 `InverseImpl.h`、`PartialPivLU.h` 和 `MatrixBase.h`）详细说明原理公式和实现逻辑。

## 1. 小尺寸矩阵的直接计算（基于伴随矩阵和行列式）

对于尺寸 ≤ 4 的方阵，Eigen 使用伴随矩阵公式：
$$
\mathbf{A}^{-1} = \frac{1}{\det(\mathbf{A})} \cdot {\bf{adj}}(\mathbf{A})
$$
其中：

- \(\det(\mathbf{A})\) 是矩阵 A 的行列式。
- \({\bf{adj}}(\mathbf{A})\) 是 A 的伴随矩阵（余因子矩阵的转置）。

Eigen 通过模板特化 `compute_inverse<MatrixType, ResultType, Size>` 来实现这些计算（在 `InverseImpl.h` 中）。

- **1x1 矩阵**：
  \[
  \mathbf{A} = [a], \quad \mathbf{A}^{-1} = \left[ \frac{1}{a} \right]
  \]
  - 实现：直接取倒数（`result.coeffRef(0,0) = Scalar(1) / matrixEval.coeff(0,0)`）。
  - 行列式：\(\det(\mathbf{A}) = a\)。
  - 检查可逆性（可选，通过 `compute_inverse_and_det_with_check`）：如果 \(|\det| > \epsilon\)（阈值），则可逆。

- **2x2 矩阵**：
  \[
  \mathbf{A} = \begin{bmatrix} a & b \\ c & d \end{bmatrix}, \quad \det(\mathbf{A}) = ad - bc
  \]
  \[
  \mathbf{A}^{-1} = \frac{1}{\det(\mathbf{A})} \begin{bmatrix} d & -b \\ -c & a \end{bmatrix}
  \]
  - 实现：先计算 \(\det = ad - bc\)，然后用辅助函数 `compute_inverse_size2_helper` 构建逆矩阵（`result.coeffRef(0,0) = matrix.coeff(1,1) * invdet` 等）。
  - 检查可逆性：如果 \(|\det| > \epsilon\)，则计算逆，否则标记为不可逆。

- **3x3 矩阵**：
  \[
  \mathbf{A} = \begin{bmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{bmatrix}
  \]
  - 行列式：\(\det(\mathbf{A}) = a_{11}(a_{22}a_{33} - a_{23}a_{32}) - a_{12}(a_{21}a_{33} - a_{23}a_{31}) + a_{13}(a_{21}a_{32} - a_{22}a_{31})\)。
  - 伴随矩阵：每个元素是对应的余因子（cofactor）的转置。余因子 \(C_{ij} = (-1)^{i+j} \det(M_{ij})\)，其中 \(M_{ij}\) 是去除 i 行 j 列的子矩阵。
  - 实现：使用辅助函数 `cofactor_3x3` 计算余因子（例如，`cofactors_col0.coeffRef(0) = cofactor_3x3<MatrixType,0,0>(matrix)`），然后用 `compute_inverse_size3_helper` 构建逆矩阵（乘以 \(1/\det\)）。
  - 检查可逆性：类似 2x2。

- **4x4 矩阵**：
  - 通用实现：使用分块方法（block-wise）计算行列式和逆。矩阵分成 2x2 块：
    \[
    \mathbf{A} = \begin{bmatrix} \mathbf{A}_{11} & \mathbf{A}_{12} \\ \mathbf{A}_{21} & \mathbf{A}_{22} \end{bmatrix}
    \]
    - 先计算 \(\mathbf{A}_{11}\) 的逆和行列式。
    - 然后计算 Schur 补（Schur complement）：\(\mathbf{S} = \mathbf{A}_{22} - \mathbf{A}_{21} \mathbf{A}_{11}^{-1} \mathbf{A}_{12}\)。
    - 行列式：\(\det(\mathbf{A}) = \det(\mathbf{A}_{11}) \cdot \det(\mathbf{S})\)。
    - 逆矩阵的分块形式：
      \[
      \mathbf{A}^{-1} = \begin{bmatrix} \mathbf{A}_{11}^{-1} + \mathbf{A}_{11}^{-1} \mathbf{A}_{12} \mathbf{S}^{-1} \mathbf{A}_{21} \mathbf{A}_{11}^{-1} & -\mathbf{A}_{11}^{-1} \mathbf{A}_{12} \mathbf{S}^{-1} \\ -\mathbf{S}^{-1} \mathbf{A}_{21} \mathbf{A}_{11}^{-1} & \mathbf{S}^{-1} \end{bmatrix}
      \]
    - 实现：在 `compute_inverse_size4` 中递归调用更小尺寸的逆计算（例如，对 2x2 块调用 2x2 逆）。
  - SSE 优化版本（当启用 SIMD 时）：使用向量指令加速余因子和行列式的计算（在 `compute_inverse_size4<Architecture::Target>` 中）。
  - 检查可逆性：类似以上。

这些小尺寸实现是高效的，因为它们避免了通用分解的开销，并在编译时优化（使用模板元编程）。

## 2. 一般尺寸矩阵的计算（基于部分主元 LU 分解）

对于尺寸 > 4 或动态尺寸的方阵，Eigen 使用部分主元 LU 分解（Partial Pivoting LU），然后通过求解线性方程组得到逆矩阵。

- **原理公式**：
  - LU 分解：\(\mathbf{A} = \mathbf{P} \mathbf{L} \mathbf{U}\)，其中：
    - \(\mathbf{P}\) 是置换矩阵（permutation matrix），用于部分主元选择以提高数值稳定性。
    - \(\mathbf{L}\) 是单位下三角矩阵（unit lower triangular）。
    - \(\mathbf{U}\) 是上三角矩阵（upper triangular）。
  - 逆矩阵：\(\mathbf{A}^{-1} = \mathbf{U}^{-1} \mathbf{L}^{-1} \mathbf{P}^{-1}\)。
  - 计算逆的过程是通过求解 \(\mathbf{A} \mathbf{X} = \mathbf{I}\)（单位矩阵），即对单位矩阵的每一列求解线性方程组：
    \[
    \mathbf{X} = \mathbf{A}^{-1} = \mathbf{P} \mathbf{L} \mathbf{U} \backslash \mathbf{I}
    \]
    - 这通过三角求解（triangular solve）实现：先求解 \(\mathbf{L} \mathbf{Y} = \mathbf{P}^{-1} \mathbf{I}\)，然后 \(\mathbf{U} \mathbf{X} = \mathbf{Y}\)。

- **实现细节**（从 `PartialPivLU.h` 和 `InverseImpl.h`）：
  - `PartialPivLU` 类执行分解：`compute()` 方法调用 `partial_lu_inplace` 或 `blocked_lu`（分块版本，用于大矩阵以优化缓存）。
    - 分解过程：在列上迭代，选择主元（pivot）以最大化稳定性（部分主元：在当前列中选择绝对值最大的元素作为主元）。
    - 存储：L 和 U 合并存储在原矩阵中（in-place），置换存储在 `m_p` 中。
  - 在 `MatrixBase::inverse()` 中，返回 `Inverse<Derived>`，然后在求值时（`Assignment` 特化）调用 `solve(MatrixType::Identity(rows, cols))`，即通过 LU 分解求解单位矩阵的逆。
  - 数值稳定性：部分主元确保主元不接近零，但不保证满秩（用户需确保矩阵可逆）。如果需要更强的稳定性，使用 FullPivLU。
  - 分块优化：对于大矩阵，使用 `blocked_lu` 分块递归计算（默认块大小 256），以利用缓存。

- **行列式计算**（辅助逆计算）：
  - 在 LU 分解中，\(\det(\mathbf{A}) = \det(\mathbf{P}) \cdot \prod {\bf{diag}}(\mathbf{U})\)（因为 \(\det(\mathbf{L}) = 1\)）。
  - \(\det(\mathbf{P}) = (-1)^k\)，其中 k 是置换的奇偶性（交换次数）。

## 附加说明

- **可逆性检查**：对于小矩阵，使用 `computeInverseAndDetWithCheck()` 计算行列式并检查 \(|\det| > \epsilon\)（默认阈值是数值精度的 dummy_precision）。对于一般矩阵，不自动检查（需用户手动用 `determinant()` 或 FullPivLU 的 rank 检查）。
- **性能考虑**：小矩阵使用直接公式（O(1) 时间，常量小）；大矩阵使用 LU（O(n^3) 时间）。Eigen 支持 SIMD 优化（SSE/AVX）和 in-place 计算以减少内存开销。
- **代码位置**：
  - 小矩阵实现：`InverseImpl.h` 中的 `compute_inverse` 特化。
  - LU 分解：`PartialPivLU.h` 中的 `partial_lu_impl` 和 `blocked_lu`。
  - 逆求值：`MatrixBase.h` 中的 `inverse()` 和 `Assignment` 特化。
