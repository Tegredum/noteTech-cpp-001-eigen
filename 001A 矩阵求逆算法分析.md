# Eigen 计算逆矩阵的原理公式

encoding: utf-8

*Grok 4 Expert*:

Eigen 是一个高效的 C++ 线性代数库，它通过 `MatrixBase::inverse()` 方法计算矩阵的逆矩阵。该方法返回一个 `Inverse<Derived>` 对象，该对象在求值时会根据矩阵的大小和类型选择不同的计算策略。Eigen 的逆矩阵计算主要基于以下原理：

1. **对于小尺寸固定矩阵（1x1、2x2、3x3、4x4）**：使用直接的代数公式，通常基于行列式（determinant）和伴随矩阵（adjugate matrix）。这些是封闭形式的计算，避免了迭代或分解的开销。
2. **对于一般尺寸矩阵**：使用部分主元 LU 分解（Partial Pivoting LU Decomposition），然后通过求解线性方程组得到逆矩阵。这是一种数值稳定的方法，适用于任意可逆方阵。

Eigen 假设矩阵是可逆的（不会自动检查奇异性，用户需自行确保）。如果需要检查可逆性，可以使用 `computeInverseAndDetWithCheck()` 或全主元 LU 分解（FullPivLU）。

下面基于提供的代码（特别是 `InverseImpl.h`、`PartialPivLU.h` 和 `MatrixBase.h`）详细说明原理公式和实现逻辑。

## 1. 小尺寸矩阵的直接计算（基于伴随矩阵和行列式）

对于尺寸 ≤ 4 的方阵，Eigen 使用伴随矩阵公式：
$$
\mathbf{A}^{-1} = \frac{1}{\det(\mathbf{A})} \cdot {\bf{adj}}(\mathbf{A})
$$
其中：

- \(\det(\mathbf{A})\) 是矩阵 A 的行列式。
- \({\bf{adj}}(\mathbf{A})\) 是 A 的伴随矩阵（余因子矩阵的转置）。

Eigen 通过模板特化 `compute_inverse<MatrixType, ResultType, Size>` 来实现这些计算（在 `InverseImpl.h` 中）。

- **1x1 矩阵**：
  \[
  \mathbf{A} = [a], \quad \mathbf{A}^{-1} = \left[ \frac{1}{a} \right]
  \]
  - 实现：直接取倒数（`result.coeffRef(0,0) = Scalar(1) / matrixEval.coeff(0,0)`）。
  - 行列式：\(\det(\mathbf{A}) = a\)。
  - 检查可逆性（可选，通过 `compute_inverse_and_det_with_check`）：如果 \(|\det| > \epsilon\)（阈值），则可逆。

- **2x2 矩阵**：
  \[
  \mathbf{A} = \begin{bmatrix} a & b \\ c & d \end{bmatrix}, \quad \det(\mathbf{A}) = ad - bc
  \]
  \[
  \mathbf{A}^{-1} = \frac{1}{\det(\mathbf{A})} \begin{bmatrix} d & -b \\ -c & a \end{bmatrix}
  \]
  - 实现：先计算 \(\det = ad - bc\)，然后用辅助函数 `compute_inverse_size2_helper` 构建逆矩阵（`result.coeffRef(0,0) = matrix.coeff(1,1) * invdet` 等）。
  - 检查可逆性：如果 \(|\det| > \epsilon\)，则计算逆，否则标记为不可逆。

- **3x3 矩阵**：
  \[
  \mathbf{A} = \begin{bmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{bmatrix}
  \]
  - 行列式：\(\det(\mathbf{A}) = a_{11}(a_{22}a_{33} - a_{23}a_{32}) - a_{12}(a_{21}a_{33} - a_{23}a_{31}) + a_{13}(a_{21}a_{32} - a_{22}a_{31})\)。
  - 伴随矩阵：每个元素是对应的余因子（cofactor）的转置。余因子 \(C_{ij} = (-1)^{i+j} \det(M_{ij})\)，其中 \(M_{ij}\) 是去除 i 行 j 列的子矩阵。
  - 实现：使用辅助函数 `cofactor_3x3` 计算余因子（例如，`cofactors_col0.coeffRef(0) = cofactor_3x3<MatrixType,0,0>(matrix)`），然后用 `compute_inverse_size3_helper` 构建逆矩阵（乘以 \(1/\det\)）。
  - 检查可逆性：类似 2x2。

- **4x4 矩阵**：
  - 通用实现：使用分块方法（block-wise）计算行列式和逆。矩阵分成 2x2 块：
    $$
    \mathbf{A} = \begin{bmatrix} \mathbf{A}_{11} & \mathbf{A}_{12} \\ \mathbf{A}_{21} & \mathbf{A}_{22} \end{bmatrix}
    $$
    - 先计算 \(\mathbf{A}_{11}\) 的逆和行列式。
    - 然后计算 Schur 补（Schur complement）：$\mathbf{S} = \mathbf{A}_{22} - \mathbf{A}_{21} \mathbf{A}_{11}^{-1} \mathbf{A}_{12}$。
    - 行列式：\(\det(\mathbf{A}) = \det(\mathbf{A}_{11}) \cdot \det(\mathbf{S})\)。
    - 逆矩阵的分块形式：
      $$
      \mathbf{A}^{-1} = \begin{bmatrix} \mathbf{A}_{11}^{-1} + \mathbf{A}_{11}^{-1} \mathbf{A}_{12} \mathbf{S}^{-1} \mathbf{A}_{21} \mathbf{A}_{11}^{-1} & -\mathbf{A}_{11}^{-1} \mathbf{A}_{12} \mathbf{S}^{-1} \\ -\mathbf{S}^{-1} \mathbf{A}_{21} \mathbf{A}_{11}^{-1} & \mathbf{S}^{-1} \end{bmatrix}
      $$
    - 实现：在 `compute_inverse_size4` 中递归调用更小尺寸的逆计算（例如，对 2x2 块调用 2x2 逆）。
  - SSE 优化版本（当启用 SIMD 时）：使用向量指令加速余因子和行列式的计算（在 `compute_inverse_size4<Architecture::Target>` 中）。
  - 检查可逆性：类似以上。

这些小尺寸实现是高效的，因为它们避免了通用分解的开销，并在编译时优化（使用模板元编程）。

## 2. 一般尺寸矩阵的计算（基于部分主元 LU 分解）

对于尺寸 > 4 或动态尺寸的方阵，Eigen 使用部分主元 LU 分解（Partial Pivoting LU），然后通过求解线性方程组得到逆矩阵。

- **原理公式**：
  - LU 分解：\(\mathbf{A} = \mathbf{P} \mathbf{L} \mathbf{U}\)，其中：
    - \(\mathbf{P}\) 是置换矩阵（permutation matrix），用于部分主元选择以提高数值稳定性。
    - \(\mathbf{L}\) 是单位下三角矩阵（unit lower triangular）。
    - \(\mathbf{U}\) 是上三角矩阵（upper triangular）。
  - 逆矩阵：\(\mathbf{A}^{-1} = \mathbf{U}^{-1} \mathbf{L}^{-1} \mathbf{P}^{-1}\)。
  - 计算逆的过程是通过求解 \(\mathbf{A} \mathbf{X} = \mathbf{I}\)（单位矩阵），即对单位矩阵的每一列求解线性方程组：
    \[
    \mathbf{X} = \mathbf{A}^{-1} = \mathbf{P} \mathbf{L} \mathbf{U} \backslash \mathbf{I}
    \]
    - 这通过三角求解（triangular solve）实现：先求解 \(\mathbf{L} \mathbf{Y} = \mathbf{P}^{-1} \mathbf{I}\)，然后 \(\mathbf{U} \mathbf{X} = \mathbf{Y}\)。

- **实现细节**（从 `PartialPivLU.h` 和 `InverseImpl.h`）：
  - `PartialPivLU` 类执行分解：`compute()` 方法调用 `partial_lu_inplace` 或 `blocked_lu`（分块版本，用于大矩阵以优化缓存）。
    - 分解过程：在列上迭代，选择主元（pivot）以最大化稳定性（部分主元：在当前列中选择绝对值最大的元素作为主元）。
    - 存储：L 和 U 合并存储在原矩阵中（in-place），置换存储在 `m_p` 中。
  - 在 `MatrixBase::inverse()` 中，返回 `Inverse<Derived>`，然后在求值时（`Assignment` 特化）调用 `solve(MatrixType::Identity(rows, cols))`，即通过 LU 分解求解单位矩阵的逆。
  - 数值稳定性：部分主元确保主元不接近零，但不保证满秩（用户需确保矩阵可逆）。如果需要更强的稳定性，使用 FullPivLU。
  - 分块优化：对于大矩阵，使用 `blocked_lu` 分块递归计算（默认块大小 256），以利用缓存。

- **行列式计算**（辅助逆计算）：
  - 在 LU 分解中，\(\det(\mathbf{A}) = \det(\mathbf{P}) \cdot \prod {\bf{diag}}(\mathbf{U})\)（因为 \(\det(\mathbf{L}) = 1\)）。
  - \(\det(\mathbf{P}) = (-1)^k\)，其中 k 是置换的奇偶性（交换次数）。

## 附加说明

- **可逆性检查**：对于小矩阵，使用 `computeInverseAndDetWithCheck()` 计算行列式并检查 \(|\det| > \epsilon\)（默认阈值是数值精度的 dummy_precision）。对于一般矩阵，不自动检查（需用户手动用 `determinant()` 或 FullPivLU 的 rank 检查）。
- **性能考虑**：小矩阵使用直接公式（O(1) 时间，常量小）；大矩阵使用 LU（O(n^3) 时间）。Eigen 支持 SIMD 优化（SSE/AVX）和 in-place 计算以减少内存开销。
- **代码位置**：
  - 小矩阵实现：`InverseImpl.h` 中的 `compute_inverse` 特化。
  - LU 分解：`PartialPivLU.h` 中的 `partial_lu_impl` 和 `blocked_lu`。
  - 逆求值：`MatrixBase.h` 中的 `inverse()` 和 `Assignment` 特化。

---

*Grok 4 Expert*:

## Eigen 矩阵求逆原理在 MATLAB 中的实现

Eigen 库在计算矩阵逆时，对于一般尺寸的可逆方阵，主要依赖部分主元 LU 分解（Partial Pivoting LU Decomposition）来确保数值稳定性。该方法将矩阵 \(\mathbf{A}\) 分解为 \(\mathbf{A} = \mathbf{P} \mathbf{L} \mathbf{U}\)，其中：

- \(\mathbf{P}\) 是置换矩阵，用于行交换以选择绝对值最大的主元，避免除以小数或零。
- \(\mathbf{L}\) 是单位下三角矩阵（对角线为 1）。
- \(\mathbf{U}\) 是上三角矩阵。

矩阵的逆 \(\mathbf{A}^{-1}\) 通过求解线性方程组 \(\mathbf{A} \mathbf{X} = \mathbf{I}\)（\(\mathbf{I}\) 为单位矩阵）获得。具体步骤：

1. 使用前向替换求解 \(\mathbf{L} \mathbf{Y} = \mathbf{P}^{-1} \mathbf{I}\)（或等价地，应用置换后求解）。
2. 使用后向替换求解 \(\mathbf{U} \mathbf{X} = \mathbf{Y}\)。

行列式 \(\det(\mathbf{A}) = (-1)^k \prod {\bf{diag}}(\mathbf{U})\)，其中 \(k\) 是置换的奇偶性（交换次数），但求逆时不直接使用行列式，仅用于可选的可逆性检查（Eigen 默认假设矩阵可逆）。

对于小尺寸矩阵（1x1 到 4x4），Eigen 使用直接代数公式（基于行列式和伴随矩阵），但以下实现聚焦一般情况的 LU 方法，以匹配 Eigen 的核心策略。MATLAB 的 `inv(A)` 内部也使用类似 LU 分解，但此处我们手动实现以展示原理。

### MATLAB 代码实现

以下 MATLAB 函数 `partialPivLUInverse` 模拟 Eigen 的部分主元 LU 求逆过程。假设输入矩阵 `A` 为方阵且可逆（无自动奇异性检查，如需添加，可计算 `det(A)` 并检查阈值）。

```matlab
function invA = partialPivLUInverse(A)
    % 输入：方阵 A
    % 输出：A 的逆矩阵 invA
    % 假设 A 可逆且方阵
    
    n = size(A, 1);
    if size(A, 1) ~= size(A, 2)
        error('矩阵必须为方阵');
    end
    
    % 初始化 LU 分解（原地存储于 L 和 U）
    LU = A;  % 复制 A 以进行原地分解
    P = 1:n;  % 初始置换向量（行索引）
    
    % 部分主元 LU 分解
    for k = 1:n-1
        % 寻找当前列 k 中绝对值最大的主元
        [~, pivotIdx] = max(abs(LU(k:n, k)));
        pivotIdx = pivotIdx + k - 1;  % 调整为全局索引
        
        % 如果主元为零，则矩阵奇异（但假设可逆，此处跳过检查）
        
        % 交换行（置换）
        if pivotIdx ~= k
            % 交换 LU 中的行
            tempRow = LU(k, :);
            LU(k, :) = LU(pivotIdx, :);
            LU(pivotIdx, :) = tempRow;
            
            % 交换置换向量 P
            tempP = P(k);
            P(k) = P(pivotIdx);
            P(pivotIdx) = tempP;
        end
        
        % 消除下三角部分（计算 L 和 U）
        for i = k+1:n
            LU(i, k) = LU(i, k) / LU(k, k);  % L 的元素（单位对角）
            for j = k+1:n
                LU(i, j) = LU(i, j) - LU(i, k) * LU(k, j);  % 更新 U
            end
        end
    end
    
    % 现在 LU 包含 L（下三角，非对角部分）和 U（上三角，包括对角）
    
    % 求解 A X = I，即 X = inv(A)
    I = eye(n);  % 单位矩阵
    invA = zeros(n, n);
    
    % 对 I 的每一列求解（使用前向和后向替换）
    for col = 1:n
        b = I(:, col);  % I 的第 col 列
        
        % 应用置换：b = P^{-1} * b（等价于 b(P)）
        bPerm = b(P, :);  % 因为 P 是行置换向量
        
        % 前向替换：求解 L y = bPerm（L 是单位下三角）
        y = zeros(n, 1);
        for i = 1:n
            y(i) = bPerm(i);
            for j = 1:i-1
                y(i) = y(i) - LU(i, j) * y(j);
            end
        end
        
        % 后向替换：求解 U x = y（U 是上三角）
        x = zeros(n, 1);
        for i = n:-1:1
            x(i) = y(i);
            for j = i+1:n
                x(i) = x(i) - LU(i, j) * x(j);
            end
            x(i) = x(i) / LU(i, i);
        end
        
        invA(:, col) = x;
    end
end
```

### 代码原理公式说明

1. **部分主元选择**：
   - 在第 \(k\) 步，扫描当前列 \(k\) 从第 \(k\) 行到第 \(n\) 行的元素，选择绝对值最大的作为主元：`[~, pivotIdx] = max(abs(LU(k:n, k)))`。
   - 这对应公式：主元 \(p = \arg\max_{i \geq k} |a_{ik}|\)，然后交换行以将主元置于对角线。
   - 目的：提高数值稳定性，避免除以小主元导致的误差放大。

2. **LU 分解过程**：
   - 对于下三角消除：\(l_{ik} = a_{ik} / a_{kk}\)（对于 \(i > k\)），然后更新子矩阵：\(a_{ij} = a_{ij} - l_{ik} \cdot a_{kj}\)（Schur 补）。
   - 原地存储：LU 矩阵的下三角（不含对角）存 L 的非对角元素，上三角（含对角）存 U。
   - MATLAB 等价：`LU(i, k) = LU(i, k) / LU(k, k)` 和内层循环更新。

3. **求解逆矩阵**：
   - 单位矩阵 \(\mathbf{I}\) 的每一列 \( \mathbf{b} \) 作为右端项。
   - 应用置换：\(\mathbf{b}' = \mathbf{P}^{-1} \mathbf{b}\)（在代码中通过 `bPerm = b(P, :)` 实现，因为 P 是行置换向量，等价于重排 b）。
   - 前向替换（L y = b'）：从上到下累积，$ y_i = b'_i - \sum_{j=1}^{i-1} l_{ij} y_j $。
   - 后向替换（U x = y）：从下到上，\( x_i = (y_i - \sum_{j=i+1}^n u_{ij} x_j) / u_{ii} \)。
   - 重复 n 次，得到逆矩阵的每一列。

此实现与 Eigen 的 PartialPivLU 类似（Eigen 使用 in-place 分解和置换向量）。在 MATLAB 中调用：`invA = partialPivLUInverse(A);`，结果应接近 `inv(A)`（数值差异可能因浮点精度而异）。如需小矩阵特殊处理，可添加条件分支使用 MATLAB 的直接公式（如 `det` 和伴随矩阵）。
