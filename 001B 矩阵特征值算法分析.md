# 矩阵特征值算法分析

encoding: utf-8

*Grok 4 Expert*:

## Eigen 库中矩阵特征值分解的算法原理

Eigen 是一个高效的 C++ 线性代数库，用于处理矩阵和向量运算。其特征值分解模块（位于 Eigenvalues 模块）针对不同类型的矩阵实现了特定的算法。这些算法基于数值线性代数中的经典方法，如 Householder 变换、QR 迭代和 Schur 分解。Eigen 的实现注重数值稳定性和性能优化，通常使用 LAPACK 或类似的后端作为参考，但其核心是纯 C++ 模板实现。

以下是对 Eigen 中矩阵特征值分解（Eigenvalue Decomposition, EVD）的详细说明。我将按矩阵类型分类讨论，因为算法因矩阵性质（如对称性或实/复数）而异。EVD 的目标是将矩阵 \( A \) 分解为 \( A = V \Lambda V^{-1} \)，其中 \( \Lambda \) 是对角矩阵（包含特征值），\( V \) 是特征向量矩阵。对于对称矩阵，\( V \) 是正交的（即 \( A = V \Lambda V^T \)）。

### 1. **对称矩阵（Self-Adjoint Matrices）的特征值分解**

   Eigen 使用 `SelfAdjointEigenSolver` 类处理实对称矩阵或复 Hermitian 矩阵。这种矩阵的特征值总是实的，且特征向量正交。这是最常见的场景，例如在主成分分析（PCA）或振动模式分析中。

**算法步骤：**

- **步骤 1: 三对角化（Tridiagonalization）**
  - 使用 Householder 变换将原始矩阵 \( A \) 转换为三对角形式 \( T \)，即 \( T = Q^T A Q \)，其中 \( Q \) 是正交矩阵。
  - Householder 变换是一种反射变换，用于引入零元素。具体而言，对于一个 \( n \times n \) 矩阵，从列 \( n-2 \) 开始迭代，每步选择一个 Householder 向量 \( u \) 使得变换 \( H = I - 2uu^T / (u^T u) \) 将子矩阵的下三角部分清零。
  - 此步骤的计算复杂度为 \( O(n^3) \)，但在 Eigen 中通过模板优化和阻塞技术加速。
  - 数值稳定性：Householder 变换是正交的，因此保持了矩阵的谱性质，避免了数值误差放大。
- **步骤 2: QL 迭代（或 QR 迭代）计算特征值**
  - 对于三对角矩阵 \( T \)，应用 QL 算法（QR 算法的变体）迭代求解特征值。
  - QL 算法的基本迭代：
    - 将 \( T \) 分解为 \( T = Q L \)，其中 \( Q \) 是正交矩阵，\( L \) 是下三角矩阵。
    - 更新 \( T \leftarrow L Q \)。
    - 重复迭代直到 \( T \) 收敛到对角形式（对角元素即特征值）。
  - Eigen 内部使用隐式移位（implicit shift）来加速收敛：选择移位 \( \sigma \)（通常基于矩阵的右下角子矩阵的特征值估计），然后进行带移位的 QL 分解 \( T - \sigma I = Q L \)，更新 \( T \leftarrow L Q + \sigma I \)。
  - 收敛性：对于对称矩阵，QL 算法是立方收敛的（每个迭代减少非对角元素的幅度）。典型迭代次数为 \( O(n) \)，总复杂度 \( O(n^2) \)。
  - 如果需要特征向量，Eigen 会累积 QL 变换矩阵，并与三对角化中的 \( Q \) 相乘得到最终 \( V \）。
- **优化与变体：**
  - 对于小矩阵（例如 \( n \leq 4 \）），Eigen 使用解析公式或 Jacobi 算法作为备选，以提高效率。
  - Jacobi 算法（可选启用）通过 Givens 旋转迭代消除非对角元素，适用于高度并行化，但对大矩阵较慢。
  - 数值稳定性：整个过程使用正交变换，确保误差在机器精度范围内。

   **示例使用：**

   ```cpp
   #include <Eigen/Eigenvalues>
   Eigen::MatrixXd A = ...;  // 对称矩阵
   Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> solver(A);
   Eigen::VectorXd eigenvalues = solver.eigenvalues();
   Eigen::MatrixXd eigenvectors = solver.eigenvectors();
   ```

### 2. **一般矩阵（Non-Symmetric Matrices）的特征值分解**

   对于非对称实矩阵或一般复矩阵，Eigen 使用 `EigenSolver` 或 `ComplexEigenSolver` 类。这些矩阵的特征值可能为复数，且特征向量不一定正交。算法基于 Schur 分解作为中间步骤。

**算法步骤：**

- **步骤 1: 矩阵平衡（Matrix Balancing，可选）**
  - 通过相似变换 \( D^{-1} A D \)（\( D \) 是对角矩阵）缩放行和列，使矩阵范数更均衡，提高数值稳定性。
  - 这减少了溢出/下溢风险，尤其对病态矩阵有效。
- **步骤 2: Hessenberg 分解（Hessenberg Decomposition）**
  - 使用 Householder 变换将 \( A \) 转换为上 Hessenberg 形式 \( H = Q^T A Q \)，其中 \( H \) 的下三角（除次对角线）为零。
  - 与三对角化类似，但仅应用于非对称矩阵。复杂度 \( O(n^3) \)。
  - Hessenberg 形式简化了后续迭代，因为 QR 分解更容易计算。
- **步骤 3: Schur 分解（Schur Decomposition）**
  - 对 Hessenberg 矩阵 \( H \) 应用 QR 算法迭代，得到实 Schur 形式 \( T = U^T H U \)，其中 \( T \) 是准上三角矩阵（对角块为 1x1 或 2x2，表示实特征值或共轭复特征值对），\( U \) 是正交矩阵。
  - QR 算法迭代：
    - 分解 \( H_k - \sigma I = Q R \)（\( Q \) 正交，\( R \) 上三角）。
    - 更新 \( H_{k+1} = R Q + \sigma I \)。
    - 使用双移位（double shift）或 Francis 移位加速收敛（移位基于 Hessenberg 矩阵的右下角子矩阵）。
  - 收敛后，\( T \) 的对角元素（或 2x2 块的特征值）即为原矩阵的特征值。
  - 复杂度：迭代部分 \( O(n^2) \)，总 \( O(n^3) \)。
  - 对于复矩阵，使用类似过程，但得到复 Schur 形式（上三角）。
- **步骤 4: 计算特征向量**
  - 从 Schur 形式 \( T \) 求解上三角系统，得到特征向量。
  - 累积所有变换矩阵（平衡、Hessenberg、Schur）得到最终 \( V \)。
  - 如果矩阵有复特征值，Eigen 会返回复特征向量。
- **优化与变体：**
  - 对于实矩阵，Eigen 使用 `RealSchur` 类进行 Schur 分解，避免不必要的复数计算。
  - 移位策略使用 Wilkinson 移位或异常移位处理难收敛情况。
  - 数值稳定性：QR 算法是向后稳定的，确保特征值误差在 \( O(\epsilon \|A\|) \) 内（\( \epsilon \) 是机器精度）。

   **示例使用：**

   ```cpp
   #include <Eigen/Eigenvalues>
   Eigen::MatrixXd A = ...;  // 一般矩阵
   Eigen::EigenSolver<Eigen::MatrixXd> solver(A);
   Eigen::VectorXcd eigenvalues = solver.eigenvalues();  // 可能为复数
   Eigen::MatrixXcd eigenvectors = solver.eigenvectors();
   ```

### 3. **通用考虑与实现细节**

- **精度与模板支持：** Eigen 使用模板支持 float、double 和自定义类型（如附件中的 mpreal.h，用于高精度）。默认使用 double。
- **并行化：** 对于大矩阵，Eigen 可利用 OpenMP 或线程进行阻塞矩阵运算，但特征值分解的核心迭代通常是串行的。
- **边界情况：** 处理零矩阵、奇异矩阵或 NaN/Inf 值，确保返回适当结果。
- **参考文献：** Eigen 的实现受 Golub & Van Loan 的《矩阵计算》（Matrix Computations）启发，与 LAPACK 的 DSYEV/DSYEVD（对称）和 DGEEV（一般）类似。
- **局限性：** 对于极大规模矩阵，Eigen 可能不如专用库（如 ARPACK）高效；不直接支持广义特征值问题（需手动转换为标准形式）。
